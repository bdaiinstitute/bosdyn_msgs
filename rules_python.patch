diff --git a/python/private/py_executable.bzl b/python/private/py_executable.bzl
index 8c0487d6..65c40582 100644
--- a/python/private/py_executable.bzl
+++ b/python/private/py_executable.bzl
@@ -863,7 +863,7 @@ def _create_providers(
             ),
         ),
         create_instrumented_files_info(ctx),
-        _create_run_environment_info(ctx, inherited_environment),
+        _create_run_environment_info(ctx, inherited_environment, cc_info),
         PyExecutableInfo(
             main = main_py,
             runfiles_without_exe = runfiles_details.runfiles_without_exe,
@@ -935,7 +935,7 @@ def _create_providers(
     providers.extend(extra_providers)
     return providers
 
-def _create_run_environment_info(ctx, inherited_environment):
+def _create_run_environment_info(ctx, inherited_environment, cc_info):
     expanded_env = {}
     for key, value in ctx.attr.env.items():
         expanded_env[key] = _py_builtins.expand_location_and_make_variables(
@@ -944,6 +944,31 @@ def _create_run_environment_info(ctx, inherited_environment):
             expression = value,
             targets = ctx.attr.data,
         )
+
+    # feat: set execution LD_LIBRARY_PATH from dynamic deps
+    #
+    # When a CcInfo specifies dynamic libraries in its transitive deps, we
+    # want to add the paths of those libraries to LD_LIBRARY_PATH so that
+    # they can be loaded when the python extension library being imported
+    # doesn't have RUNPATH info (for example, it was built outside of bazel).
+    #
+    # See https://bazelbuild.slack.com/archives/CA306CEV6/p1737601588845769
+    #
+    ld_library_path = {}
+    for input in cc_info.linking_context.linker_inputs.to_list():
+        for input_library in input.libraries:
+            library = input_library.dynamic_library
+            if not library:
+                continue
+            path = library.short_path.removesuffix(library.basename).rstrip("/")
+            ld_library_path[path] = True
+
+    if ld_library_path:
+        parts = []
+        parts += [expanded_env["LD_LIBRARY_PATH"]] if "LD_LIBRARY_PATH" in expanded_env else []
+        parts += ld_library_path.keys()
+        expanded_env["LD_LIBRARY_PATH"] = ":".join(parts)
+
     return RunEnvironmentInfo(
         environment = expanded_env,
         inherited_environment = inherited_environment,
